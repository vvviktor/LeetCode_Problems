## Решение задачи [4. Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)

Нам даны два отсортированных по неубыванию массива целых чисел размеров `n` и `m` соответственно. Требуется найти ***медиану*** двух массивов. Авторы просят сделать это за O(log^2(n + m)) временной сложности. 

![](https://github.com/vvviktor/LeetCode_Problems/blob/main/4_Median_of_Two_Sorted_Arrays/Img/Case_B/1b.jpg)

То есть, если даны массивы `A` и `B`, нас интересует медиана объединенного массива `A + B`. Простым решением было бы объединить массивы за O(m + n) и найти медиану за O(1). Но авторы хотят, чтобы сложность была ниже, и объединение массивов становится недоступной операцией.

Что если попытаться решить задачу ***бинарным поиском***? Надо только понять что искать. Применительно к задаче, ***медиана*** - это значение элемента отсортированного массива, имеющего слева и справа от себя одинаковое количество элементов. В случае нечетного количества элементов это центральный элемент, в случае четного - арифметическое среднее значений двух центральных элементов. Если еще точнее, то нужно найти значение элемента объединенного массива по индеку `k = (n + m) / 2` для нечетного количества элементов, а в случае с четным количеством элементов понадобится еще элемент по индексу `k - 1`. В обоих случаях известно, что перед искомым элементом (элементами) все элементы **меньше** или равны, а после - **больше** или равны искомому. Нам нужен `k`-ый минимальный элемент в общем массиве.

![](/Img/Case_B/2b.jpg)

Традиционно бинарный поиск позволяет на каждой итерации определять в какой половине исходных данных находится искомый элемент. И позволяет отказаться от дальнейшего поиска в той половине, где его точно нет. Обозначим границы исходных массивов как `[l1, r1)` для `A`, и `[l2, r2)` для `B`. Если в каждом из двух исходных массивов `A` и `B` найти средние индексы `mid1` и `mid2`, то, если `A[mid1] <= B[mid2]`, можно представить объединенный массив как сочетание подмножеств `[l1, mid1) + [mid1, r1) + [l2, mid2) + [mid2, r2)` из которых только первое и последнее ***гарантированно не пересекаются*** со своими соседями. Наш искомый элемент имел бы индекс `k = (n + m) / 2`, если бы мы имели дело с объединенным массивом длины `n + m`. Если сумма индексов `mid1 + mid2` меньше `k`, то искомый элемент находится в большем подмножестве. При этом нам точно известно что единственное меньшее подмножество, не пересекающее границу `k` в объединенном массиве будет `[l1, mid1)`, если `mid1 < mid2` или `[l2, mid2)`, если `mid2 < mid1`. От поиска в нем можно отказаться, переназначив соответствующие указатели. Если сумма индексов `mid1 + mid2` больше или равна `k`, то поступить следует зеркально - отказаться от поиска в крайнем правом подмножестве.

На следующих иллюстрациях показана дальнейшая работа алгоритма:

![](/Img/Case_B/3b.jpg)

![](/Img/Case_B/4b.jpg)

![](/Img/Case_B/5b.jpg)

![](/Img/Case_B/6b.jpg)

![](/Img/Case_B/7b.jpg)

Базовым случаем будет `l == r` в любом из массивов. В этом случае уже отсечены `n` или `m` соответственно значений, предшествующих искомому. Нужно только определить индекс искомого элемента в оставшемся массиве: `k - r`, где `r` - правый индекс "пустого" массива.

Для случая, когда `n + m` - четное нужно просто еще раз запустить алгоритм для поиска `k - 1`-го минимального элемента в общем массиве.

Мое рекурсивное решение [здесь](binary_search.cpp). Его временная сложность O(log^2(n + m)), пространственная - такая же, так как глубина рекурсии составит log^2(n + m). Однако, рекурсия здесь ***хвостовая***, и решение, скорее всего будет оптимизировано с помощью циклов до O(1) пространственной сложности. 