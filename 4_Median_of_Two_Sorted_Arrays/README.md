## Решение задачи [4. Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)

Здесь опишу один из трудных для понимания алгоритмов своими словами с использованием своих иллюстраций.

Нам даны два отсортированных по неубыванию массива целых чисел размеров `n` и `m` соответственно. Требуется найти ***медиану*** двух массивов. Авторы просят сделать это за O(log^2(n + m)) временной сложности. 

![](https://github.com/vvviktor/LeetCode_Problems/blob/main/4_Median_of_Two_Sorted_Arrays/Img/Case_B/1b.jpg)

То есть, если даны массивы `A` и `B`, нас интересует медиана объединенного массива `A + B`. Простым решением было бы объединить массивы за O(m + n) и найти медиану за O(1). Но авторы хотят, чтобы сложность была ниже, и объединение массивов становится недоступной операцией.

Что если попытаться решить задачу ***бинарным поиском***? Надо только понять что искать. Применительно к задаче, ***медиана*** - это значение элемента отсортированного массива, имеющего слева и справа от себя одинаковое количество элементов. В случае нечетного количества элементов это центральный элемент, в случае четного - арифметическое среднее значений двух центральных элементов. Если еще точнее, то нужно найти значение элемента объединенного массива по индексу `k = (n + m) / 2` для нечетного количества элементов, а в случае с четным количеством элементов понадобится еще элемент по индексу `k - 1`. В обоих случаях известно, что перед искомым элементом (элементами) все элементы **меньше** или равны, а после - **больше** или равны искомому. Применительно к нечетному количеству исходных элементов (на примере выше) нам нужен `k + 1`-ый минимальный элемент в общем массиве, элемент, который имел бы индекс равный `k` при 0 - индексации.

Традиционно бинарный поиск позволяет на каждой итерации определять в какой половине исходных данных находится искомый элемент. И позволяет отказаться от дальнейшего поиска в той половине, где его точно нет. 

![](https://github.com/vvviktor/LeetCode_Problems/blob/main/4_Median_of_Two_Sorted_Arrays/Img/Case_B/1p.jpg)

Если в исходных массивах `A` и `B` найти средние элементы, то мы получим 4 отсортированных по неубыванию отрезка с элементами общего массива `A + B`, распределенными так, что в массиве с большим значением среднего элемента (на рисунке это массив `B` и значение `24`), будут преимущественно элементы из правой части общего массива, а в массиве с меньшим значением среднего элемента будет больше элементов из левой части массива `A + B`. То есть, будут отрезки `A_left` и `B_right`, которые не пересекают центр массива `A + B` в его первоначальных границах. Можем ли мы отбросить любой из этих отрезков, так как они не включают элемент по индексу `k` общего массива? 

Рассмотрим первый шаг. Исходные массивы (зона поиска) включают все элементы общего множества.

![](https://github.com/vvviktor/LeetCode_Problems/blob/main/4_Median_of_Two_Sorted_Arrays/Img/Case_B/2b.jpg)

Для начала нужно понять в какой части исходных множеств может располагаться `k + 1`-ый элемент общего множества. В нашем примере это 11-ый по счету меньший элемент общего множества (имеет индекс `k == 10`). То есть и в исходных массивах он находится среди 11-и наименьших элементов. В нашем алгоритме бинарного поиска для корректной работы без зацикливания мы **всегда** включаем средний индекс (обозначен желтым) в отбрасываемую часть. А сами индексы расчитываются как:

```
int mid1 = l1 + (r1 - l1) / 2;
int mid2 = l2 + (r2 - l2) / 2;
```

Соответственно, для четных массивов средний индекс будет всегда располагаться в правой части массива, а для нечетных - будет медианным.

Если на рассматриваемом примере посчитать количество элементов в меньшей части **включая** элементы по желтым индексам, то мы насчитаем 12 элементов. При этом только 11-ый из них может оказаться в отбрасываемой части (помним, что отбрасываем в этом случае мы только самую левую или наименьшую часть общего множества). Если так же посчитать количество элементов в правых частях, опять же **включая** средние элементы, то получим 11 элементов, при этом только 10-ый из них может оказаться в большей (содержащей наибольшие значения) отбрасываемой части. То есть, зная, что `k = A_B.size() / 2`, и `k + 1 = A_B.size() / 2 + 1`, в случае, когда `k + 1 <= (A.size() + B.size()) / 2 + 1` или `k <= (A.size() + B.size()) / 2` мы можем отбрасывать только самую правую часть из исходных данных. Ведь, если `k == (A.size() + B.size()) / 2`, элемент по индексу `k` рискует быть отброшенным, так как `k + 1`-ый наменьший элемент общего множества может оказаться в наименьшей отбрасывапемой части исходных данных. 

Это эффект легко проверить на минимальных размерах общих данных, которые возможно разбить на два подмножества. Для четного размера данных это общее множество из 2-х элементов, для нечетного размера - из 3-х. Помним, что `k = A_B.size() / 2`. В четном будем искать `k + 1`-ый и `k`-ый элементы, в нечетном - только `k + 1`-ый. При любом отсортированном распределении `k + 1`-ый элемент не попадает в правую часть исходных данных после распределения. А значит, именно правую часть следует отбрасывать, если `k + 1 <= (A.size() + B.size()) / 2 + 1`. При поиске `k`-го элемента ответ на вопрос очевиден, так как `k < k + 1`, а значит при обработке всего дипазона `k`-ый элемент всегда будет в левой части после распределения исходных данных.  

Первый шаг сделан. Часть исходных данных отброшена. В какой части оставшихся данных может находиться элемент по индексу `k`? В общем множестве теперь отсутствует ряд элементов справа от индекса `k`, то есть, если из исходных данных отброшено 7 элементов правее `k + 1`-го, то в оставшихся данных искомый элемент будет уже `k + 1 + 7`-ым по счету. То есть, искомый элемент по отношению к зоне поиска смещается в сторону из которой были отброшены значения на предыдущей итерации. Если мы не отбрасываем элементы из исходных данных, а только передвигаем границы поиска, то можно переформулировать эту зависимость применительно к индексу `k`. Обнаружится такая же зависимость суммы индексов `mid1 + mid2` от исходного `k`, как и суммы размеров зоны поиска от порядкового номера искомого элемента в этой зоне.

![](https://github.com/vvviktor/LeetCode_Problems/blob/main/4_Median_of_Two_Sorted_Arrays/Img/Case_B/2p.jpg)

Пунктирной линией в общем множестве обозначен индекс `midA + midB`. Если алгоритм сужает зону поиска, отбрасывая часть элементов, не пересекающую искомый элемент, то при последующих расчетах эта пунктирная линия будет смещаться в общем массиве, что точно подскажет нам какую часть данных можно отбросить в дальнейшем.

Так как мы не хотим выбросить из зоны поиска искомый элемент `k`, то в случае, когда он меньше или равен сумме средних индексов массивов `A` и `B`, отбросим большую (правую) непересекающуюся часть, а в случае, когда `k > midA + midB` отбросим меньшую непересекающуюся часть.

На следующих иллюстрациях показана дальнейшая работа алгоритма:

![](https://github.com/vvviktor/LeetCode_Problems/blob/main/4_Median_of_Two_Sorted_Arrays/Img/Case_B/3b.jpg)

![](https://github.com/vvviktor/LeetCode_Problems/blob/main/4_Median_of_Two_Sorted_Arrays/Img/Case_B/4b.jpg)

![](https://github.com/vvviktor/LeetCode_Problems/blob/main/4_Median_of_Two_Sorted_Arrays/Img/Case_B/5b.jpg)

![](https://github.com/vvviktor/LeetCode_Problems/blob/main/4_Median_of_Two_Sorted_Arrays/Img/Case_B/6b.jpg)

![](https://github.com/vvviktor/LeetCode_Problems/blob/main/4_Median_of_Two_Sorted_Arrays/Img/Case_B/7b.jpg)

Базовым случаем будет `l == r` в любом из массивов. В этом случае уже отсечены `n` или `m` соответственно значений, предшествующих искомому. Нужно только определить индекс искомого элемента в оставшемся массиве: `k - r`, где `r` - правый индекс "пустого" массива.

Для случая, когда `n + m` - четное нужно просто еще раз запустить алгоритм для поиска `k - 1`-го минимального элемента в общем массиве.

Мое рекурсивное решение [здесь](binary_search.cpp). Его временная сложность O(log^2(n + m)), пространственная - такая же, так как глубина рекурсии составит log^2(n + m). Однако, рекурсия здесь ***хвостовая***, и решение, скорее всего, будет оптимизировано с помощью циклов до O(1) пространственной сложности. 