## Решение задачи [4. Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)

Нам даны два отсортированных по неубыванию массива целых чисел размеров `n` и `m` соответственно. Требуется найти ***медиану*** двух массивов. Авторы просят сделать это за O(log^2(n + m)) временной сложности. 

![](https://github.com/vvviktor/LeetCode_Problems/blob/main/4_Median_of_Two_Sorted_Arrays/Img/Case_B/1b.jpg)

То есть, если даны массивы `A` и `B`, нас интересует медиана объединенного массива `A + B`. Простым решением было бы объединить массивы за O(m + n) и найти медиану за O(1). Но авторы хотят, чтобы сложность была ниже, и объединение массивов становится недоступной операцией.

Что если попытаться решить задачу ***бинарным поиском***? Надо только понять что искать. Применительно к задаче, ***медиана*** - это значение элемента отсортированного массива, имеющего слева и справа от себя одинаковое количество элементов. В случае нечетного количества элементов это центральный элемент, в случае четного - арифметическое среднее значений двух центральных элементов. Если еще точнее, то нужно найти значение элемента объединенного массива по индеку `k = (n + m) / 2` для нечетного количества элементов, а в случае с четным количеством элементов понадобится еще элемент по индексу `k - 1`. В обоих случаях известно, что перед искомым элементом (элементами) все элементы **меньше** или равны, а после - **больше** или равны искомому. Нам нужен `k`-ый минимальный элемент в общем массиве.

Традиционно бинарный поиск позволяет на каждой итерации определять в какой половине исходных данных находится искомый элемент. И позволяет отказаться от дальнейшего поиска в той половине, где его точно нет. 

![](https://github.com/vvviktor/LeetCode_Problems/blob/main/4_Median_of_Two_Sorted_Arrays/Img/Case_B/1p.jpg)

Если в исходных массивах `A` и `B` найти средние элементы, то мы получим 4 отсортированных по неубыванию отрезка с элементами общего массива `A + B`, распределенными так, что в массиве с большим значением среднего элемента (на рисунке это массив `B` и значение `24`), будут преимущественно элементы из правой части общего массива, а в массиве с меньшим значением среднего элемента будет больше элементов из левой части массива `A + B`. То есть, будут отрезки `A_left` и `B_right`, которые не пересекают центр массива `A + B` в его первоначальных границах. Мы можем отбросить любой из этих отрезков, так как они не включают элемент `k` общего массива. Пунктирной линией обозначен медианный элемент для зон поиска в исходных массивах равный `midA + midB`. Если алгоритм сужает зону поиска, отбрасывая часть элементов, не пересекающую искомый элемент, то при последующих расчетах эта пунктирная линия будет смещаться в общем массиве, что точно подскажет нам какую часть данных можно отбросить в дальнейшем.

![](https://github.com/vvviktor/LeetCode_Problems/blob/main/4_Median_of_Two_Sorted_Arrays/Img/Case_B/2p.jpg)

Так как мы не хотим выбросить из зоны поиска искомый элемент `k`, то в случае, когда он меньше или равен сумме средних индексов массивов `A` и `B`, отбросим большую (правую) непересекающуюся часть, а в случае, когда `k > midA + midB` отбросим меньшую непересекающуюся часть.

На следующих иллюстрациях показана дальнейшая работа алгоритма:

![](https://github.com/vvviktor/LeetCode_Problems/blob/main/4_Median_of_Two_Sorted_Arrays/Img/Case_B/2b.jpg)

![](https://github.com/vvviktor/LeetCode_Problems/blob/main/4_Median_of_Two_Sorted_Arrays/Img/Case_B/3b.jpg)

![](https://github.com/vvviktor/LeetCode_Problems/blob/main/4_Median_of_Two_Sorted_Arrays/Img/Case_B/4b.jpg)

![](https://github.com/vvviktor/LeetCode_Problems/blob/main/4_Median_of_Two_Sorted_Arrays/Img/Case_B/5b.jpg)

![](https://github.com/vvviktor/LeetCode_Problems/blob/main/4_Median_of_Two_Sorted_Arrays/Img/Case_B/6b.jpg)

![](https://github.com/vvviktor/LeetCode_Problems/blob/main/4_Median_of_Two_Sorted_Arrays/Img/Case_B/7b.jpg)

Базовым случаем будет `l == r` в любом из массивов. В этом случае уже отсечены `n` или `m` соответственно значений, предшествующих искомому. Нужно только определить индекс искомого элемента в оставшемся массиве: `k - r`, где `r` - правый индекс "пустого" массива.

Для случая, когда `n + m` - четное нужно просто еще раз запустить алгоритм для поиска `k - 1`-го минимального элемента в общем массиве.

Мое рекурсивное решение [здесь](binary_search.cpp). Его временная сложность O(log^2(n + m)), пространственная - такая же, так как глубина рекурсии составит log^2(n + m). Однако, рекурсия здесь ***хвостовая***, и решение, скорее всего будет оптимизировано с помощью циклов до O(1) пространственной сложности. 